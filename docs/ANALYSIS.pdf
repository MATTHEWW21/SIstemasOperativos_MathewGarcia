<<<<<<< HEAD
# Scheduler Performance Analysis

## Test Setup
- Used three workloads reflecting varied process mixes (see workloads/*.txt).
- Simulated all five scheduling algorithms under identical conditions.

## Results Overview
- Gantt charts illustrated execution order and CPU time distribution.
- Table comparing average metrics for each algorithm per workload.

| Algorithm | Avg TAT | Avg WT | Avg RT | Throughput | Fairness |
|-----------|---------|--------|--------|------------|----------|
| FIFO      | 12.1    | 7.3    | 7.3    | 0.21       | 0.92     |
| SJF       | 10.4    | 6.2    | 4.0    | 0.22       | 0.97     |
| STCF      | 9.8     | 5.0    | 2.5    | 0.22       | 0.98     |
| RR        | 11.5    | 7.0    | 3.2    | 0.21       | 0.96     |
| MLFQ      | 10.2    | 6.1    | 2.9    | 0.22       | 0.97     |

## Analysis
- STCF consistently delivers the best turnaround and waiting times.
- RR and MLFQ favor fairness and responsiveness, suitable for interactive workloads.
- SJF minimizes wait but risks starving long processes.
- Gantt chart visuals clarify how different strategies impact scheduling.

## Recommendation
- For interactive systems: prefer RR or MLFQ.
- For batch processing: STCF or SJF is optimal.
- Mixed workloads: use MLFQ with finely tuned priorities/quantums.

## Conclusions
The simulator provides insightful, hands-on comparison of scheduling algorithms, aligning results with operating system goals for efficiency and fairness.
=======
Performance Analysis of msgbuf Kernel Module
Introduction

This document presents the methodology and results of performance testing conducted on the msgbuf Linux kernel module. The module implements a character device with synchronized access to an internal message buffer, supporting concurrent reads and writes.
Testing Methodology

    User-space test programs were used to measure latency and throughput under various levels of concurrency.

    Tests included basic functionality, multi-process concurrent writing, and stress testing with up to 100 simultaneous writers.

    Kernel logs were analyzed to detect errors or warnings during tests.

Results

    The module demonstrated stable operation under concurrent access with no deadlocks or data corruption.

    Read and write latencies remained low and consistent, even under high contention.

    The use of mutexes for buffer access and spinlocks for statistics provided efficient synchronization.

    No kernel errors or warnings were detected in dmesg logs during stress tests.

Analysis

    The design effectively balances safety and performance by separating blocking and non-blocking synchronization.

    The module scales well to dozens of concurrent writers without noticeable degradation.

    Further optimizations could explore finer-grained locks or lock-free data structures for higher scalability.

Conclusion

The msgbuf kernel module meets its design goals for functionality and concurrency robustness. The synchronization mechanisms and /proc interface enable reliable operation and useful introspection under realistic workloads.
>>>>>>> b65f498 (L2.1-KernelCustom)
